```sql
-- ==========================================
-- SECTION A: FUNCTIONS (1 - 35)
-- Oracle PL/SQL
-- ==========================================

-- 0) Helper: create sample tables if not present (minimal)
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE dept (dept_id NUMBER PRIMARY KEY, dept_name VARCHAR2(100))';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -955 THEN RAISE; END IF; -- ignore ORA-00955 if exists
END;
/

BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE emp (
    emp_id NUMBER PRIMARY KEY,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    email VARCHAR2(100),
    salary NUMBER,
    dept_id NUMBER,
    hire_date DATE,
    commission_pct NUMBER,
    job_title VARCHAR2(50),
    manager_id NUMBER,
    created_date DATE,
    last_updated_by VARCHAR2(30)
  )';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE emp_audit (
    audit_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    emp_id NUMBER,
    action_type VARCHAR2(20),
    action_date DATE,
    old_salary NUMBER,
    new_salary NUMBER,
    changed_by VARCHAR2(30)
  )';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

-- 1: function to return square of a number
CREATE OR REPLACE FUNCTION fn_square (p_num IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN p_num * p_num;
END;
/

-- 2: factorial (non-negative integer)
CREATE OR REPLACE FUNCTION fn_factorial (p_n IN PLS_INTEGER) RETURN NUMBER IS
  v_fact NUMBER := 1;
BEGIN
  IF p_n < 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Negative number not allowed');
  END IF;
  FOR i IN 1 .. GREATEST(1,p_n) LOOP
    v_fact := v_fact * i;
  END LOOP;
  RETURN v_fact;
END;
/

-- 3: total salary of all employees
CREATE OR REPLACE FUNCTION fn_total_salary RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT NVL(SUM(salary),0) INTO v_total FROM emp;
  RETURN v_total;
END;
/

-- 4: accept emp id and return name (first + last)
CREATE OR REPLACE FUNCTION fn_get_emp_name (p_empid IN NUMBER) RETURN VARCHAR2 IS
  v_name VARCHAR2(200);
BEGIN
  SELECT NVL(first_name,'') || ' ' || NVL(last_name,'') INTO v_name FROM emp WHERE emp_id = p_empid;
  RETURN v_name;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN NULL;
END;
/

-- 5: return department name for given dept id
CREATE OR REPLACE FUNCTION fn_get_dept_name (p_deptid IN NUMBER) RETURN VARCHAR2 IS
  v_name VARCHAR2(200);
BEGIN
  SELECT dept_name INTO v_name FROM dept WHERE dept_id = p_deptid;
  RETURN v_name;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN NULL;
END;
/

-- 6: check even or odd
CREATE OR REPLACE FUNCTION fn_even_odd (p_num IN NUMBER) RETURN VARCHAR2 IS
BEGIN
  IF MOD(TRUNC(p_num),2) = 0 THEN
    RETURN 'EVEN';
  ELSE
    RETURN 'ODD';
  END IF;
END;
/

-- 7: return current date and time
CREATE OR REPLACE FUNCTION fn_current_datetime RETURN DATE IS
BEGIN
  RETURN SYSDATE;
END;
/

-- 8: area of a circle given radius
CREATE OR REPLACE FUNCTION fn_area_circle (p_radius IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN 3.141592653589793 * p_radius * p_radius;
END;
/

-- 9: number of employees in a specific department
CREATE OR REPLACE FUNCTION fn_emp_count_in_dept (p_deptid IN NUMBER) RETURN NUMBER IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM emp WHERE dept_id = p_deptid;
  RETURN v_count;
END;
/

-- 10: maximum salary from EMP table
CREATE OR REPLACE FUNCTION fn_max_salary RETURN NUMBER IS
  v_max NUMBER;
BEGIN
  SELECT NVL(MAX(salary),0) INTO v_max FROM emp;
  RETURN v_max;
END;
/

-- 11: convert Celsius to Fahrenheit
CREATE OR REPLACE FUNCTION fn_c_to_f (p_celsius IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN (p_celsius * 9/5) + 32;
END;
/

-- 12: return commission percentage of an employee
CREATE OR REPLACE FUNCTION fn_comm_pct (p_empid IN NUMBER) RETURN NUMBER IS
  v_comm NUMBER;
BEGIN
  SELECT commission_pct INTO v_comm FROM emp WHERE emp_id = p_empid;
  RETURN v_comm;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN NULL;
END;
/

-- 13: count employees with salary above 5000
CREATE OR REPLACE FUNCTION fn_count_above_5000 RETURN NUMBER IS
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM emp WHERE salary > 5000;
  RETURN v_cnt;
END;
/

-- 14: nth Fibonacci number (1-indexed: fn_fib(1)=0, fn_fib(2)=1)
CREATE OR REPLACE FUNCTION fn_fibonacci (p_n IN PLS_INTEGER) RETURN NUMBER IS
  a NUMBER := 0;
  b NUMBER := 1;
  temp NUMBER;
BEGIN
  IF p_n <= 0 THEN
    RETURN NULL;
  ELSIF p_n = 1 THEN
    RETURN a;
  ELSIF p_n = 2 THEN
    RETURN b;
  ELSE
    FOR i IN 3 .. p_n LOOP
      temp := a + b;
      a := b;
      b := temp;
    END LOOP;
    RETURN b;
  END IF;
END;
/

-- 15: reverse a string
CREATE OR REPLACE FUNCTION fn_reverse_str (p_str IN VARCHAR2) RETURN VARCHAR2 IS
  v_res VARCHAR2(4000) := '';
BEGIN
  IF p_str IS NULL THEN RETURN NULL; END IF;
  FOR i IN REVERSE 1 .. LENGTH(p_str) LOOP
    v_res := v_res || SUBSTR(p_str,i,1);
  END LOOP;
  RETURN v_res;
END;
/

-- 16: return length of string without LENGTH()
CREATE OR REPLACE FUNCTION fn_strlen_no_length (p_str IN VARCHAR2) RETURN PLS_INTEGER IS
  v_len PLS_INTEGER := 0;
BEGIN
  IF p_str IS NULL THEN RETURN 0; END IF;
  FOR i IN 1 .. 4000 LOOP
    BEGIN
      DECLARE ch CHAR := SUBSTR(p_str,i,1); BEGIN NULL; END;
    EXCEPTION WHEN OTHERS THEN
      EXIT;
    END;
    EXIT WHEN SUBSTR(p_str,i,1) IS NULL;
    v_len := v_len + 1;
  END LOOP;
  RETURN v_len;
END;
/

-- 17: compound interest -> amount after n periods: A = P*(1+r/n)^(n*t) ; here p_rate is annual rate in percent,
-- periods_per_year = p_m (compounds per year), years = p_years; returns amount
CREATE OR REPLACE FUNCTION fn_compound_interest (p_principal IN NUMBER, p_rate IN NUMBER, p_m IN PLS_INTEGER, p_years IN NUMBER) RETURN NUMBER IS
  v_amount NUMBER;
  v_r NUMBER := p_rate / 100;
BEGIN
  IF p_m <= 0 OR p_years < 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Invalid inputs for compound interest');
  END IF;
  v_amount := p_principal * POWER(1 + v_r / p_m, p_m * p_years);
  RETURN v_amount;
END;
/

-- 18: employee yearly salary (salary * 12)
CREATE OR REPLACE FUNCTION fn_yearly_salary (p_empid IN NUMBER) RETURN NUMBER IS
  v_salary NUMBER;
BEGIN
  SELECT salary INTO v_salary FROM emp WHERE emp_id = p_empid;
  RETURN v_salary * 12;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
/

-- 19: minimum salary of a department
CREATE OR REPLACE FUNCTION fn_min_salary_in_dept (p_deptid IN NUMBER) RETURN NUMBER IS
  v_min NUMBER;
BEGIN
  SELECT MIN(salary) INTO v_min FROM emp WHERE dept_id = p_deptid;
  RETURN v_min;
END;
/

-- 20: check leap year
CREATE OR REPLACE FUNCTION fn_is_leap_year (p_year IN PLS_INTEGER) RETURN VARCHAR2 IS
BEGIN
  IF MOD(p_year,400) = 0 THEN
    RETURN 'YES';
  ELSIF MOD(p_year,100) = 0 THEN
    RETURN 'NO';
  ELSIF MOD(p_year,4) = 0 THEN
    RETURN 'YES';
  ELSE
    RETURN 'NO';
  END IF;
END;
/

-- 21: count vowels in a string
CREATE OR REPLACE FUNCTION fn_count_vowels (p_str IN VARCHAR2) RETURN PLS_INTEGER IS
  v_count PLS_INTEGER := 0;
  v_char CHAR(1);
BEGIN
  IF p_str IS NULL THEN RETURN 0; END IF;
  FOR i IN 1 .. LENGTH(p_str) LOOP
    v_char := LOWER(SUBSTR(p_str,i,1));
    IF v_char IN ('a','e','i','o','u') THEN
      v_count := v_count + 1;
    END IF;
  END LOOP;
  RETURN v_count;
END;
/

-- 22: greater of two numbers
CREATE OR REPLACE FUNCTION fn_greater (p_a IN NUMBER, p_b IN NUMBER) RETURN NUMBER IS
BEGIN
  IF p_a >= p_b THEN RETURN p_a; ELSE RETURN p_b; END IF;
END;
/

-- 23: total number of departments
CREATE OR REPLACE FUNCTION fn_total_departments RETURN NUMBER IS
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM dept;
  RETURN v_cnt;
END;
/

-- 24: last hired employee name (most recent hire_date)
CREATE OR REPLACE FUNCTION fn_last_hired_name RETURN VARCHAR2 IS
  v_name VARCHAR2(200);
BEGIN
  SELECT first_name || ' ' || last_name INTO v_name FROM (
    SELECT * FROM emp ORDER BY hire_date DESC NULLS LAST
  ) WHERE ROWNUM = 1;
  RETURN v_name;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
/

-- 25: employee name uppercase
CREATE OR REPLACE FUNCTION fn_emp_name_upper (p_empid IN NUMBER) RETURN VARCHAR2 IS
  v_name VARCHAR2(200);
BEGIN
  SELECT UPPER(NVL(first_name,'') || ' ' || NVL(last_name,'')) INTO v_name FROM emp WHERE emp_id = p_empid;
  RETURN v_name;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
/

-- 26: grade based on salary (A: >10000, B: 5000-10000, C: <5000) - example thresholds
CREATE OR REPLACE FUNCTION fn_salary_grade (p_empid IN NUMBER) RETURN CHAR IS
  v_sal NUMBER;
BEGIN
  SELECT salary INTO v_sal FROM emp WHERE emp_id = p_empid;
  IF v_sal > 10000 THEN RETURN 'A';
  ELSIF v_sal >= 5000 THEN RETURN 'B';
  ELSE RETURN 'C';
  END IF;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
/

-- 27: sum of digits of a number
CREATE OR REPLACE FUNCTION fn_sum_digits (p_num IN NUMBER) RETURN PLS_INTEGER IS
  v_val NUMBER := ABS(TRUNC(p_num));
  v_sum PLS_INTEGER := 0;
BEGIN
  WHILE v_val > 0 LOOP
    v_sum := v_sum + MOD(v_val,10);
    v_val := TRUNC(v_val/10);
  END LOOP;
  RETURN v_sum;
END;
/

-- 28: square root (uses POWER)
CREATE OR REPLACE FUNCTION fn_sqrt (p_num IN NUMBER) RETURN NUMBER IS
BEGIN
  IF p_num < 0 THEN
    RAISE_APPLICATION_ERROR(-20003, 'Negative not allowed');
  END IF;
  RETURN POWER(p_num, 0.5);
END;
/

-- 29: count employees joined in a given year
CREATE OR REPLACE FUNCTION fn_count_joined_year (p_year IN NUMBER) RETURN NUMBER IS
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM emp WHERE EXTRACT(YEAR FROM hire_date) = p_year;
  RETURN v_cnt;
END;
/

-- 30: return job title of an employee id
CREATE OR REPLACE FUNCTION fn_job_title (p_empid IN NUMBER) RETURN VARCHAR2 IS
  v_job VARCHAR2(100);
BEGIN
  SELECT job_title INTO v_job FROM emp WHERE emp_id = p_empid;
  RETURN v_job;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
/

-- 31: average of two numbers
CREATE OR REPLACE FUNCTION fn_avg_two (p_a IN NUMBER, p_b IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN (p_a + p_b) / 2;
END;
/

-- 32: check palindrome
CREATE OR REPLACE FUNCTION fn_is_palindrome (p_str IN VARCHAR2) RETURN VARCHAR2 IS
  v_rev VARCHAR2(4000);
  v_norm VARCHAR2(4000);
BEGIN
  IF p_str IS NULL THEN RETURN 'NO'; END IF;
  v_norm := LOWER(REPLACE(p_str,' ','')); -- basic normalization
  v_rev := fn_reverse_str(v_norm);
  IF v_norm = v_rev THEN RETURN 'YES'; ELSE RETURN 'NO'; END IF;
END;
/

-- 33: days between two dates
CREATE OR REPLACE FUNCTION fn_days_between (p_dt1 IN DATE, p_dt2 IN DATE) RETURN NUMBER IS
BEGIN
  RETURN ABS(TRUNC(p_dt2) - TRUNC(p_dt1));
END;
/

-- 34: return email domain part (after @)
CREATE OR REPLACE FUNCTION fn_email_domain (p_email IN VARCHAR2) RETURN VARCHAR2 IS
  v_pos NUMBER;
BEGIN
  IF p_email IS NULL THEN RETURN NULL; END IF;
  v_pos := INSTR(p_email,'@');
  IF v_pos = 0 THEN RETURN NULL; ELSE RETURN SUBSTR(p_email, v_pos+1); END IF;
END;
/

-- 35: salary range => HIGH/MEDIUM/LOW
CREATE OR REPLACE FUNCTION fn_salary_range_label (p_salary IN NUMBER) RETURN VARCHAR2 IS
BEGIN
  IF p_salary IS NULL THEN RETURN NULL; END IF;
  IF p_salary >= 10000 THEN RETURN 'HIGH';
  ELSIF p_salary >= 5000 THEN RETURN 'MEDIUM';
  ELSE RETURN 'LOW';
  END IF;
END;
/

-- ==========================================
-- SECTION B: PROCEDURES (36 - 70)
-- ==========================================

-- 36: procedure to insert a new employee record
CREATE OR REPLACE PROCEDURE pr_insert_employee (
  p_empid IN NUMBER,
  p_first IN VARCHAR2,
  p_last IN VARCHAR2,
  p_email IN VARCHAR2,
  p_salary IN NUMBER,
  p_deptid IN NUMBER,
  p_hiredate IN DATE,
  p_comm IN NUMBER,
  p_job IN VARCHAR2,
  p_manager IN NUMBER
) IS
BEGIN
  INSERT INTO emp(emp_id, first_name, last_name, email, salary, dept_id, hire_date, commission_pct, job_title, manager_id, created_date)
  VALUES (p_empid, p_first, p_last, p_email, p_salary, p_deptid, p_hiredate, p_comm, p_job, p_manager, SYSDATE);
  COMMIT;
END;
/

-- 37: update an employee's salary
CREATE OR REPLACE PROCEDURE pr_update_salary (p_empid IN NUMBER, p_new_salary IN NUMBER) IS
  v_old NUMBER;
BEGIN
  SELECT salary INTO v_old FROM emp WHERE emp_id = p_empid;
  UPDATE emp SET salary = p_new_salary, last_updated_by = USER WHERE emp_id = p_empid;
  INSERT INTO emp_audit(emp_id, action_type, action_date, old_salary, new_salary, changed_by)
    VALUES (p_empid, 'SALARY_UPDATE', SYSDATE, v_old, p_new_salary, USER);
  COMMIT;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR(-20004,'Employee not found');
END;
/

-- 38: delete employee by id
CREATE OR REPLACE PROCEDURE pr_delete_employee (p_empid IN NUMBER) IS
BEGIN
  DELETE FROM emp WHERE emp_id = p_empid;
  COMMIT;
END;
/

-- 39: print all employee names
CREATE OR REPLACE PROCEDURE pr_print_all_emp_names IS
  CURSOR c IS SELECT first_name, last_name FROM emp;
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(NVL(v_row.first_name,'') || ' ' || NVL(v_row.last_name,''));
  END LOOP;
  CLOSE c;
END;
/

-- 40: accept emp id and print details
CREATE OR REPLACE PROCEDURE pr_print_emp_details (p_empid IN NUMBER) IS
  v_first VARCHAR2(50);
  v_last VARCHAR2(50);
  v_salary NUMBER;
  v_dept NUMBER;
BEGIN
  SELECT first_name, last_name, salary, dept_id INTO v_first, v_last, v_salary, v_dept FROM emp WHERE emp_id = p_empid;
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_first || ' ' || v_last || ' Salary: ' || v_salary || ' Dept: ' || v_dept);
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Employee not found'); END;
/

-- 41: give 10% salary hike to all employees in a dept
CREATE OR REPLACE PROCEDURE pr_hike_10pct_dept (p_deptid IN NUMBER) IS
BEGIN
  UPDATE emp SET salary = salary * 1.10 WHERE dept_id = p_deptid;
  COMMIT;
END;
/

-- 42: increase salary by given percentage
CREATE OR REPLACE PROCEDURE pr_increase_salary_by_pct (p_pct IN NUMBER) IS
BEGIN
  IF p_pct <= -100 THEN RAISE_APPLICATION_ERROR(-20005,'Invalid pct'); END IF;
  UPDATE emp SET salary = salary * (1 + p_pct/100);
  COMMIT;
END;
/

-- 43: copy data from one table to another (simple)
CREATE OR REPLACE PROCEDURE pr_copy_emp_to_emp_backup IS
BEGIN
  BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE emp_backup AS SELECT * FROM emp WHERE 1=0';
  EXCEPTION WHEN OTHERS THEN NULL; END;
  EXECUTE IMMEDIATE 'INSERT INTO emp_backup SELECT * FROM emp';
  COMMIT;
END;
/

-- 44: delete all employees with salary < 3000
CREATE OR REPLACE PROCEDURE pr_delete_low_salary IS
BEGIN
  DELETE FROM emp WHERE salary < 3000;
  COMMIT;
END;
/

-- 45: display total salary per department
CREATE OR REPLACE PROCEDURE pr_total_salary_per_dept IS
  CURSOR c IS SELECT d.dept_name, NVL(SUM(e.salary),0) total_sal
             FROM dept d LEFT JOIN emp e ON d.dept_id = e.dept_id
             GROUP BY d.dept_name;
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_row.dept_name || ' => ' || v_row.total_sal);
  END LOOP;
  CLOSE c;
END;
/

-- 46: log the count of rows in a table into LOG_TABLE
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE log_table (log_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, table_name VARCHAR2(100), row_count NUMBER, log_date DATE, username VARCHAR2(30))';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -955 THEN RAISE; END IF;
END;
/

CREATE OR REPLACE PROCEDURE pr_log_row_count (p_table IN VARCHAR2) IS
  v_count NUMBER;
BEGIN
  EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table INTO v_count;
  INSERT INTO log_table(table_name, row_count, log_date, username) VALUES (p_table, v_count, SYSDATE, USER);
  COMMIT;
EXCEPTION WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('Error logging row count: ' || SQLERRM);
END;
/

-- 47: accept dept name and return id via OUT parameter
CREATE OR REPLACE PROCEDURE pr_get_dept_id_by_name (p_deptname IN VARCHAR2, p_deptid OUT NUMBER) IS
BEGIN
  SELECT dept_id INTO p_deptid FROM dept WHERE dept_name = p_deptname;
EXCEPTION WHEN NO_DATA_FOUND THEN p_deptid := NULL; END;
/

-- 48: truncate a table dynamically
CREATE OR REPLACE PROCEDURE pr_truncate_table (p_table_name IN VARCHAR2) IS
BEGIN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE ' || p_table_name;
END;
/

-- 49: display employees whose name starts with 'A'
CREATE OR REPLACE PROCEDURE pr_emp_names_start_a IS
  CURSOR c IS SELECT first_name, last_name FROM emp WHERE UPPER(first_name) LIKE 'A%';
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_row.first_name || ' ' || v_row.last_name);
  END LOOP;
  CLOSE c;
END;
/

-- 50: fetch highest-paid employee
CREATE OR REPLACE PROCEDURE pr_highest_paid_employee IS
  v_name VARCHAR2(200);
  v_sal NUMBER;
BEGIN
  SELECT first_name||' '||last_name, salary INTO v_name, v_sal
    FROM emp WHERE salary = (SELECT MAX(salary) FROM emp) AND ROWNUM = 1;
  DBMS_OUTPUT.PUT_LINE('Highest paid: '||v_name||' Salary:'||v_sal);
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('No employees'); END;
/

-- 51: update job title based on salary range (example)
CREATE OR REPLACE PROCEDURE pr_update_job_based_on_salary IS
BEGIN
  UPDATE emp SET job_title = 'SENIOR' WHERE salary >= 15000;
  UPDATE emp SET job_title = 'MID' WHERE salary >= 7000 AND salary < 15000;
  UPDATE emp SET job_title = 'JUNIOR' WHERE salary < 7000;
  COMMIT;
END;
/

-- 52: insert multiple records by loop (demo inserts N copies)
CREATE OR REPLACE PROCEDURE pr_insert_multiple (p_count IN NUMBER) IS
BEGIN
  FOR i IN 1 .. p_count LOOP
    INSERT INTO emp(emp_id, first_name, last_name, salary, created_date)
      VALUES (emp_seq.NEXTVAL, 'Bulk' || i, 'User' || i, 5000, SYSDATE);
  END LOOP;
  COMMIT;
EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('Ensure emp_seq exists or handle duplicates: '||SQLERRM);
END;
/

-- 53: print all department names
CREATE OR REPLACE PROCEDURE pr_print_all_dept_names IS
  CURSOR c IS SELECT dept_name FROM dept;
  v_name VARCHAR2(100);
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name);
  END LOOP;
  CLOSE c;
END;
/

-- 54: find employees without commission
CREATE OR REPLACE PROCEDURE pr_employees_without_commission IS
  CURSOR c IS SELECT emp_id, first_name || ' ' || last_name name FROM emp WHERE commission_pct IS NULL;
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_row.emp_id || ' - ' || v_row.name);
  END LOOP;
  CLOSE c;
END;
/

-- 55: accept two dates and show employees hired in between
CREATE OR REPLACE PROCEDURE pr_emp_hired_between (p_from IN DATE, p_to IN DATE) IS
  CURSOR c IS SELECT emp_id, first_name || ' ' || last_name name, hire_date FROM emp WHERE hire_date BETWEEN p_from AND p_to;
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_row.emp_id || ' ' || v_row.name || ' ' || v_row.hire_date);
  END LOOP;
  CLOSE c;
END;
/

-- 56: transfer employees from one dept to another
CREATE OR REPLACE PROCEDURE pr_transfer_dept (p_from_dept IN NUMBER, p_to_dept IN NUMBER) IS
BEGIN
  UPDATE emp SET dept_id = p_to_dept WHERE dept_id = p_from_dept;
  COMMIT;
END;
/

-- 57: log audit data in separate table
CREATE OR REPLACE PROCEDURE pr_log_audit (p_empid IN NUMBER, p_action IN VARCHAR2) IS
BEGIN
  INSERT INTO emp_audit(emp_id, action_type, action_date, changed_by) VALUES (p_empid, p_action, SYSDATE, USER);
  COMMIT;
END;
/

-- 58: delete duplicate employee records (keep min emp_id)
CREATE OR REPLACE PROCEDURE pr_delete_duplicate_emps IS
BEGIN
  DELETE FROM emp e WHERE e.emp_id NOT IN (
    SELECT MIN(emp_id) FROM emp GROUP BY email  -- assuming email uniqueness desired
  );
  COMMIT;
END;
/

-- 59: print even numbers 1 to 50
CREATE OR REPLACE PROCEDURE pr_print_even_1_50 IS
BEGIN
  FOR i IN 1 .. 50 LOOP
    IF MOD(i,2) = 0 THEN DBMS_OUTPUT.PUT_LINE(i); END IF;
  END LOOP;
END;
/

-- 60: generate Fibonacci series up to N terms
CREATE OR REPLACE PROCEDURE pr_fib_series (p_n IN PLS_INTEGER) IS
  a NUMBER := 0; b NUMBER := 1; temp NUMBER;
BEGIN
  IF p_n <= 0 THEN RETURN; END IF;
  DBMS_OUTPUT.PUT_LINE(a);
  IF p_n = 1 THEN RETURN; END IF;
  DBMS_OUTPUT.PUT_LINE(b);
  FOR i IN 3 .. p_n LOOP
    temp := a + b;
    DBMS_OUTPUT.PUT_LINE(temp);
    a := b; b := temp;
  END LOOP;
END;
/

-- 61: reverse a given string (prints)
CREATE OR REPLACE PROCEDURE pr_reverse_string (p_str IN VARCHAR2) IS
  v_rev VARCHAR2(4000) := fn_reverse_str(p_str);
BEGIN
  DBMS_OUTPUT.PUT_LINE(v_rev);
END;
/

-- 62: print all prime numbers between 1 and 100
CREATE OR REPLACE PROCEDURE pr_print_primes_1_100 IS
  FUNCTION is_prime(n NUMBER) RETURN BOOLEAN IS
  BEGIN
    IF n <= 1 THEN RETURN FALSE; ELSIF n <= 3 THEN RETURN TRUE; END IF;
    IF MOD(n,2)=0 THEN RETURN FALSE; END IF;
    DECLARE i NUMBER := 3; BEGIN
      WHILE i*i <= n LOOP
        IF MOD(n,i)=0 THEN RETURN FALSE; END IF;
        i := i + 2;
      END LOOP;
    END;
    RETURN TRUE;
  END;
BEGIN
  FOR n IN 1..100 LOOP
    IF is_prime(n) THEN DBMS_OUTPUT.PUT_LINE(n); END IF;
  END LOOP;
END;
/

-- 63: factorial of a given number (prints)
CREATE OR REPLACE PROCEDURE pr_print_factorial (p_n IN PLS_INTEGER) IS
  v_fact NUMBER := fn_factorial(p_n);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Factorial('||p_n||') = '||v_fact);
END;
/

-- 64: accept a table name and print row count dynamically
CREATE OR REPLACE PROCEDURE pr_table_row_count (p_table IN VARCHAR2) IS
  v_rowcount NUMBER;
BEGIN
  EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM '||p_table INTO v_rowcount;
  DBMS_OUTPUT.PUT_LINE('Table '||p_table||' has '||v_rowcount||' rows.');
END;
/

-- 65: find employees with NULL manager IDs
CREATE OR REPLACE PROCEDURE pr_emps_without_manager IS
  CURSOR c IS SELECT emp_id, first_name||' '||last_name name FROM emp WHERE manager_id IS NULL;
  v_row c%ROWTYPE;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO v_row;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_row.emp_id||' - '||v_row.name);
  END LOOP;
  CLOSE c;
END;
/

-- 66: update salaries of employees hired before 2010
CREATE OR REPLACE PROCEDURE pr_update_salary_hired_before_2010 IS
BEGIN
  UPDATE emp SET salary = salary * 1.05 WHERE hire_date < TO_DATE('01-JAN-2010','DD-MON-YYYY');
  COMMIT;
END;
/

-- 67: delete rows older than 30 days from a log table
CREATE OR REPLACE PROCEDURE pr_delete_old_logs IS
BEGIN
  DELETE FROM log_table WHERE log_date < SYSDATE - 30;
  COMMIT;
END;
/

-- 68: accept emp id and display their department and job
CREATE OR REPLACE PROCEDURE pr_emp_dept_job (p_empid IN NUMBER) IS
  v_dept VARCHAR2(100);
  v_job VARCHAR2(100);
BEGIN
  SELECT d.dept_name, e.job_title INTO v_dept, v_job FROM emp e LEFT JOIN dept d ON e.dept_id = d.dept_id WHERE e.emp_id = p_empid;
  DBMS_OUTPUT.PUT_LINE('Dept: '||NVL(v_dept,'N/A')||' Job: '||NVL(v_job,'N/A'));
EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('Employee not found');
END;
/

-- 69: insert today's date and username into a log table
CREATE OR REPLACE PROCEDURE pr_insert_log_user IS
BEGIN
  INSERT INTO log_table(table_name, row_count, log_date, username) VALUES ('MANUAL_LOG', 0, SYSDATE, USER);
  COMMIT;
END;
/

-- 70: print the number of days in the current month
CREATE OR REPLACE PROCEDURE pr_days_in_current_month IS
  v_first DATE := TRUNC(SYSDATE, 'MM');
  v_last DATE := LAST_DAY(SYSDATE);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Days this month: ' || (v_last - v_first + 1));
END;
/

-- ==========================================
-- SECTION C: TRIGGERS (71 - 100)
-- ==========================================

-- 71: BEFORE INSERT trigger on EMP to set CREATED_DATE = SYSDATE
CREATE OR REPLACE TRIGGER trg_emp_before_insert_created_date
BEFORE INSERT ON emp
FOR EACH ROW
BEGIN
  :NEW.created_date := NVL(:NEW.created_date, SYSDATE);
END;
/

-- 72: AFTER INSERT trigger to log new records into EMP_AUDIT
CREATE OR REPLACE TRIGGER trg_emp_after_insert_audit
AFTER INSERT ON emp
FOR EACH ROW
BEGIN
  INSERT INTO emp_audit(emp_id, action_type, action_date, new_salary, changed_by)
    VALUES (:NEW.emp_id, 'INSERT', SYSDATE, :NEW.salary, USER);
END;
/

-- 73: BEFORE UPDATE trigger to prevent salary reduction
CREATE OR REPLACE TRIGGER trg_prevent_salary_reduction
BEFORE UPDATE OF salary ON emp
FOR EACH ROW
BEGIN
  IF :NEW.salary < NVL(:OLD.salary,0) THEN
    RAISE_APPLICATION_ERROR(-20006, 'Salary reduction not allowed');
  END IF;
END;
/

-- 74: AFTER DELETE trigger to record deleted rows in another table (EMP_HISTORY)
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE emp_history AS SELECT * FROM emp WHERE 1=0';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_emp_after_delete_history
AFTER DELETE ON emp
FOR EACH ROW
BEGIN
  INSERT INTO emp_history(emp_id, first_name, last_name, email, salary, dept_id, hire_date, commission_pct, job_title, manager_id, created_date, last_updated_by)
  VALUES (:OLD.emp_id, :OLD.first_name, :OLD.last_name, :OLD.email, :OLD.salary, :OLD.dept_id, :OLD.hire_date, :OLD.commission_pct, :OLD.job_title, :OLD.manager_id, :OLD.created_date, :OLD.last_updated_by);
END;
/

-- 75: BEFORE INSERT trigger to assign emp_id from sequence
BEGIN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE emp_seq START WITH 1000 INCREMENT BY 1';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_emp_before_insert_seq
BEFORE INSERT ON emp
FOR EACH ROW
WHEN ( :NEW.emp_id IS NULL )
BEGIN
  SELECT emp_seq.NEXTVAL INTO :NEW.emp_id FROM dual;
END;
/

-- 76: AFTER UPDATE trigger to log old and new salary values
CREATE OR REPLACE TRIGGER trg_emp_after_update_salary_log
AFTER UPDATE OF salary ON emp
FOR EACH ROW
BEGIN
  INSERT INTO emp_audit(emp_id, action_type, action_date, old_salary, new_salary, changed_by)
    VALUES (:OLD.emp_id, 'SALARY_CHANGED', SYSDATE, :OLD.salary, :NEW.salary, USER);
END;
/

-- 77: BEFORE DELETE trigger to prevent deletion of managers
CREATE OR REPLACE TRIGGER trg_prevent_delete_managers
BEFORE DELETE ON emp
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM emp WHERE manager_id = :OLD.emp_id;
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20007, 'Cannot delete manager with reporting employees');
  END IF;
END;
/

-- 78: trigger that prevents updates on weekends
CREATE OR REPLACE TRIGGER trg_prevent_updates_weekend
BEFORE UPDATE OR DELETE ON emp
FOR EACH ROW
BEGIN
  IF TO_CHAR(SYSDATE,'DY','NLS_DATE_LANGUAGE=ENGLISH') IN ('SAT','SUN') THEN
    RAISE_APPLICATION_ERROR(-20008,'Updates/deletes not allowed on weekends');
  END IF;
END;
/

-- 79: trigger to set LAST_UPDATED_BY = USER on update
CREATE OR REPLACE TRIGGER trg_set_last_updated_by
BEFORE UPDATE ON emp
FOR EACH ROW
BEGIN
  :NEW.last_updated_by := USER;
END;
/

-- 80: prevent insertion of duplicate email IDs
CREATE OR REPLACE TRIGGER trg_prevent_duplicate_email
BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM emp WHERE email = :NEW.email AND (emp_id != NVL(:NEW.emp_id, -1));
  IF v_count > 0 THEN
    RAISE_APPLICATION_ERROR(-20009,'Duplicate email not allowed');
  END IF;
END;
/

-- 81: trigger that calculates annual salary after each salary update (stores into a column if exists)
-- If column annual_salary doesn't exist, ignore (this is a demo)
BEGIN
  BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE emp ADD (annual_salary NUMBER)';
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
END;
/

CREATE OR REPLACE TRIGGER trg_calc_annual_salary
BEFORE INSERT OR UPDATE OF salary ON emp
FOR EACH ROW
BEGIN
  :NEW.annual_salary := NVL(:NEW.salary,0) * 12;
END;
/

-- 82: allow inserts only during office hours (9–5)
CREATE OR REPLACE TRIGGER trg_allow_insert_office_hours
BEFORE INSERT ON emp
FOR EACH ROW
DECLARE
  v_hour NUMBER := TO_NUMBER(TO_CHAR(SYSDATE,'HH24'));
BEGIN
  IF v_hour < 9 OR v_hour >= 17 THEN
    RAISE_APPLICATION_ERROR(-20010,'Inserts allowed only between 09:00 and 17:00');
  END IF;
END;
/

-- 83: trigger that logs login attempts in LOGIN_LOG table
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE login_log (log_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY, username VARCHAR2(50), attempt_date DATE, success CHAR(1))';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE PROCEDURE pr_log_login_attempt (p_user IN VARCHAR2, p_success IN CHAR) IS
BEGIN
  INSERT INTO login_log(username, attempt_date, success) VALUES (p_user, SYSDATE, p_success);
  COMMIT;
END;
/

-- 84: set DEFAULT department to 'GENERAL' if NULL
CREATE OR REPLACE TRIGGER trg_default_dept_general
BEFORE INSERT ON emp
FOR EACH ROW
BEGIN
  IF :NEW.dept_id IS NULL THEN
    SELECT dept_id INTO :NEW.dept_id FROM dept WHERE dept_name = 'GENERAL' AND ROWNUM = 1;
    -- if GENERAL doesn't exist, fallback to NULL
  END IF;
EXCEPTION WHEN NO_DATA_FOUND THEN NULL;
END;
/

-- 85: prevent deletion of rows from DEPARTMENT table
CREATE OR REPLACE TRIGGER trg_prevent_delete_dept
BEFORE DELETE ON dept
FOR EACH ROW
BEGIN
  RAISE_APPLICATION_ERROR(-20011,'Department deletion not allowed');
END;
/

-- 86: prevent updating primary key of EMP (emp_id)
CREATE OR REPLACE TRIGGER trg_prevent_update_emp_pk
BEFORE UPDATE OF emp_id ON emp
FOR EACH ROW
BEGIN
  RAISE_APPLICATION_ERROR(-20012,'emp_id PK cannot be updated');
END;
/

-- 87: automatically populate audit columns (UPDATED_BY, UPDATED_ON) on update
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE emp ADD (updated_by VARCHAR2(30), updated_on DATE)';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_update_audit_cols
BEFORE UPDATE ON emp
FOR EACH ROW
BEGIN
  :NEW.updated_by := USER;
  :NEW.updated_on := SYSDATE;
END;
/

-- 88: restrict inserting records if total count exceeds 1000
CREATE OR REPLACE TRIGGER trg_restrict_insert_1000
BEFORE INSERT ON emp
DECLARE
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM emp;
  IF v_cnt >= 1000 THEN
    RAISE_APPLICATION_ERROR(-20013, 'Cannot insert: table has 1000 or more rows');
  END IF;
END;
/

-- 89: trigger that fires when a table is truncated
-- Oracle: TRUNCATE does not fire row-level triggers, but DDL trigger can detect 'TRUNCATE TABLE'
CREATE OR REPLACE TRIGGER trg_ddl_truncate AFTER TRUNCATE ON SCHEMA BEGIN NULL; END;
/

-- 90: stop inserts if salary > 100000
CREATE OR REPLACE TRIGGER trg_stop_high_salary
BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW
BEGIN
  IF :NEW.salary > 100000 THEN
    RAISE_APPLICATION_ERROR(-20014,'Salary exceeds allowed maximum of 100000');
  END IF;
END;
/

-- 91: auto populate full_name column (first + last)
BEGIN
  BEGIN EXECUTE IMMEDIATE 'ALTER TABLE emp ADD (full_name VARCHAR2(200))'; EXCEPTION WHEN OTHERS THEN NULL; END;
END;
/

CREATE OR REPLACE TRIGGER trg_populate_fullname
BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW
BEGIN
  :NEW.full_name := NVL(:NEW.first_name,'') || ' ' || NVL(:NEW.last_name,'');
END;
/

-- 92: record time difference between insert and update (add column if needed)
BEGIN
  BEGIN EXECUTE IMMEDIATE 'ALTER TABLE emp ADD (insert_time DATE, update_time DATE, time_diff_in_seconds NUMBER)';
  EXCEPTION WHEN OTHERS THEN NULL; END;
END;
/

CREATE OR REPLACE TRIGGER trg_record_insert_time
BEFORE INSERT ON emp
FOR EACH ROW
BEGIN
  :NEW.insert_time := SYSDATE;
END;
/

CREATE OR REPLACE TRIGGER trg_record_update_time_diff
BEFORE UPDATE ON emp
FOR EACH ROW
BEGIN
  :NEW.update_time := SYSDATE;
  IF :OLD.insert_time IS NOT NULL THEN
    :NEW.time_diff_in_seconds := (SYSDATE - :OLD.insert_time) * 24 * 60 * 60;
  END IF;
END;
/

-- 93: prevent inserting rows with NULL email
CREATE OR REPLACE TRIGGER trg_prevent_null_email
BEFORE INSERT ON emp
FOR EACH ROW
BEGIN
  IF :NEW.email IS NULL THEN
    RAISE_APPLICATION_ERROR(-20015,'Email cannot be NULL');
  END IF;
END;
/

-- 94: copy deleted employee data into HISTORY table (already implemented in trigger 74)
-- (trg_emp_after_delete_history above)

-- 95: trigger that fires before UPDATE on DEPT and raises error if dept_name changes
CREATE OR REPLACE TRIGGER trg_dept_name_change_prevent
BEFORE UPDATE OF dept_name ON dept
FOR EACH ROW
BEGIN
  IF :OLD.dept_name != :NEW.dept_name THEN
    RAISE_APPLICATION_ERROR(-20016,'Changing department name is not allowed');
  END IF;
END;
/

-- 96: maintain a row count in another table after each insert/delete (ROW_COUNT_TABLE)
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE row_count_table (tbl_name VARCHAR2(100) PRIMARY KEY, row_count NUMBER)';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_maintain_rowcount
AFTER INSERT OR DELETE ON emp
DECLARE
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM emp;
  MERGE INTO row_count_table r USING (SELECT 'EMP' tbl FROM dual) src
  ON (r.tbl_name = src.tbl)
  WHEN MATCHED THEN UPDATE SET r.row_count = v_cnt
  WHEN NOT MATCHED THEN INSERT (tbl_name, row_count) VALUES (src.tbl, v_cnt);
END;
/

-- 97: prevent modification of system admin accounts (assume email 'admin@company' is system admin)
CREATE OR REPLACE TRIGGER trg_prevent_modify_admin
BEFORE UPDATE OR DELETE ON emp
FOR EACH ROW
BEGIN
  IF NVL(:OLD.email,'') = 'admin@company' THEN
    RAISE_APPLICATION_ERROR(-20017,'System admin cannot be modified');
  END IF;
END;
/

-- 98: set BONUS = 0 if salary < 5000 (add column if not present)
BEGIN
  BEGIN EXECUTE IMMEDIATE 'ALTER TABLE emp ADD (bonus NUMBER)'; EXCEPTION WHEN OTHERS THEN NULL; END;
END;
/

CREATE OR REPLACE TRIGGER trg_set_bonus_zero
BEFORE INSERT OR UPDATE ON emp
FOR EACH ROW
BEGIN
  IF :NEW.salary < 5000 THEN
    :NEW.bonus := 0;
  END IF;
END;
/

-- 99: log username and date whenever salary is modified
CREATE OR REPLACE TRIGGER trg_log_username_when_salary_mod
AFTER UPDATE OF salary ON emp
FOR EACH ROW
BEGIN
  INSERT INTO emp_audit(emp_id, action_type, action_date, old_salary, new_salary, changed_by)
    VALUES (:OLD.emp_id, 'SALARY_MOD_LOG', SYSDATE, :OLD.salary, :NEW.salary, USER);
END;
/

-- 100: disable inserts into EMP table on Sundays
CREATE OR REPLACE TRIGGER trg_disable_insert_sunday
BEFORE INSERT ON emp
FOR EACH ROW
BEGIN
  IF TO_CHAR(SYSDATE,'DY','NLS_DATE_LANGUAGE=ENGLISH') = 'SUN' THEN
    RAISE_APPLICATION_ERROR(-20018,'Inserts disabled on Sundays');
  END IF;
END;
/
```

---